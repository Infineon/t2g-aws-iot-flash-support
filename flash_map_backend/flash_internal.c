/**********************************************************************************************************************
 * \file flash_internal.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "string.h"
#include "stdlib.h"
#include "stdbool.h"
#include <assert.h>
#include "cy_device_headers.h"
#include "flash_internal.h"
#include "cy_flash.h"
#include "cy_syspm.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define IF_WR_SUCCESS 0
#define IF_WR_ERROR_INVALID_PARAMETER 1
#define IF_WR_ERROR_FLASH_WRITE 2

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef enum
{
    IF_IN_BOUNDS,
    IF_OUT_OF_BOUNDS,
    IF_ON_BOUNDS,
} if_bounds_t;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
static uint8_t  workBuff[CY_CODE_LES_SIZE_IN_BYTE];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/**********************************************************************************************************************
 * Function Name: IfMainBoundsCheck
 * Summary:
 *  Checks the address value is inside of the internal flash region
 * Parameters:
 *  uint32_t address
 * Return:
 *  if_bounds_t
 **********************************************************************************************************************
 */
static if_bounds_t IfMainBoundsCheck(uint32_t address)
{
    cy_en_bankmode_t bankMode = (cy_en_bankmode_t)_FLD2VAL(FLASHC_FLASH_CTL_MAIN_BANK_MODE,FLASHC_FLASH_CTL);

    if (bankMode == CY_FLASH_SINGLE_BANK_MODE)
    {
        if ((CY_FLASH_LG_SBM_TOP <= address) && (address < CY_FLASH_LG_SBM_END))
        {
            if ((address - CY_FLASH_LG_SBM_TOP) % CY_CODE_LES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_LG_SBM_END)
        {
            return IF_ON_BOUNDS;
        }
        else if ((CY_FLASH_SM_SBM_TOP <= address) && (address < CY_FLASH_SM_SBM_END))
        {
            if ((address - CY_FLASH_SM_SBM_TOP) % CY_CODE_SES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_SM_SBM_END)
        {
            return IF_ON_BOUNDS;
        }
    }
    else
    {
        if ((CY_FLASH_LG_DBM0_TOP <= address) && (address < CY_FLASH_LG_DBM0_END))
        {
            if ((address - CY_FLASH_LG_DBM0_TOP) % CY_CODE_LES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_LG_DBM0_END)
        {
            return IF_ON_BOUNDS;
        }
        else if ((CY_FLASH_SM_DBM0_TOP <= address) && (address < CY_FLASH_SM_DBM0_END))
        {
            if ((address - CY_FLASH_SM_DBM0_TOP) % CY_CODE_SES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_SM_DBM0_END)
        {
            return IF_ON_BOUNDS;
        }
        else if ((CY_FLASH_LG_DBM1_TOP <= address) && (address < CY_FLASH_LG_DBM1_END))
        {
            if ((address - CY_FLASH_LG_DBM1_TOP) % CY_CODE_LES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_LG_DBM1_END)
        {
            return IF_ON_BOUNDS;
        }
        else if ((CY_FLASH_SM_DBM1_TOP <= address) && (address < CY_FLASH_SM_DBM1_END))
        {
            if ((address - CY_FLASH_SM_DBM1_TOP) % CY_CODE_SES_SIZE_IN_BYTE)
            {
                return IF_IN_BOUNDS;
            }
            return IF_ON_BOUNDS;
        }
        else if (address == CY_FLASH_SM_DBM1_END)
        {
            return IF_ON_BOUNDS;
        }
    }

    return IF_OUT_OF_BOUNDS;
}

/**********************************************************************************************************************
 * Function Name: IfGetSectorTopAddr
 * Summary:
 *  Get sector boundary of specified address.
 *  If the 2nd argument 'next' is true, the address to be returned is top of next sector.
 *  Otherwise ('next' is false), the address to be returned is top of current sector.
 *  If the address is out of flash region, returns IF_OUT_OF_BOUNDS. otherwise returns IF_ON_BOUNDS.
 * Parameters:
 *  uint32_t *address
 *  bool next
 * Return:
 *  if_bounds_t
 **********************************************************************************************************************
 */
static if_bounds_t IfGetSectorTopAddr(uint32_t *address, bool next)
{
    uint32_t mod, sectSize;
    cy_en_bankmode_t bankMode = (cy_en_bankmode_t)_FLD2VAL(FLASHC_FLASH_CTL_MAIN_BANK_MODE,FLASHC_FLASH_CTL);

    if (bankMode == CY_FLASH_SINGLE_BANK_MODE)
    {
        if (( CY_FLASH_LG_SBM_TOP <= *address) && (*address < CY_FLASH_LG_SBM_END))
        {
            mod = (*address - CY_FLASH_LG_SBM_TOP) % CY_CODE_LES_SIZE_IN_BYTE;
            sectSize = CY_CODE_LES_SIZE_IN_BYTE;
        }
        else if (( CY_FLASH_SM_SBM_TOP <= *address) && (*address < CY_FLASH_SM_SBM_END))
        {
            mod = (*address - CY_FLASH_SM_SBM_TOP) % CY_CODE_SES_SIZE_IN_BYTE;
            sectSize = CY_CODE_SES_SIZE_IN_BYTE;
        }
        else
        {
            return IF_OUT_OF_BOUNDS;
        }
    }
    else
    {
        if (( CY_FLASH_LG_DBM0_TOP <= *address) && (*address < CY_FLASH_LG_DBM0_END))
        {
            mod = (*address - CY_FLASH_LG_DBM0_TOP) % CY_CODE_LES_SIZE_IN_BYTE;
            sectSize = CY_CODE_LES_SIZE_IN_BYTE;
        }
        else if (( CY_FLASH_SM_DBM0_TOP <= *address) && (*address < CY_FLASH_SM_DBM0_END))
        {
            mod = (*address - CY_FLASH_SM_DBM0_TOP) % CY_CODE_SES_SIZE_IN_BYTE;
            sectSize = CY_CODE_SES_SIZE_IN_BYTE;
        }
        else if (( CY_FLASH_LG_DBM1_TOP <= *address) && (*address < CY_FLASH_LG_DBM1_END))
        {
            mod = (*address - CY_FLASH_LG_DBM1_TOP) % CY_CODE_LES_SIZE_IN_BYTE;
            sectSize = CY_CODE_LES_SIZE_IN_BYTE;
        }
        else if (( CY_FLASH_SM_DBM1_TOP <= *address) && (*address < CY_FLASH_SM_DBM1_END))
        {
            mod = (*address - CY_FLASH_SM_DBM1_TOP) % CY_CODE_SES_SIZE_IN_BYTE;
            sectSize = CY_CODE_SES_SIZE_IN_BYTE;
        }
        else
        {
            return IF_OUT_OF_BOUNDS;
        }
    }
    if (next)
    {
        *address += (sectSize - mod);
    }
    else
    {
        *address -= mod;
    }

    return IF_ON_BOUNDS;
}

/**********************************************************************************************************************
 * Function Name: IfWrite
 * Summary:
 *  This function writes the data to the PSOC6's Flash. It will check the
 *  appropriate alignment of a start address and also perform an address range
 *  check based on the length before performing the write operation.
 *  This function performs memory compare and writes only row where there are new data to write.
 * Parameters:
 *  uint8_t addr[]: Pointer to the buffer containing the data to be stored.
 *  uint32_t address: Pointer to the array or variable in the flash.
 *  uint32_t len: The length of the data in bytes.
 * Return:
 *  int
 *   IF_WR_SUCCESS                  A successful write
 *   IF_WR_ERROR_INVALID_PARAMETER  At least one of the input parameters is invalid
 *   IF_WR_ERROR_FLASH_WRITE        Error in flash Write
 **********************************************************************************************************************
 */
static int IfWrite(uint8_t data[], uint32_t address, uint32_t len)
{
    int retCode;
    cy_en_flashdrv_status_t rc = CY_FLASH_DRV_SUCCESS;
    uint32_t                size;
    if_bounds_t             boundsStart, boundsEnd;

    /* Make sure, that varFlash[] points to Flash */
    boundsStart = IfMainBoundsCheck(address);
    boundsEnd   = IfMainBoundsCheck(address + len);

    Cy_Flashc_MainWriteEnable();

    if ((boundsStart != IF_OUT_OF_BOUNDS) && (boundsEnd != IF_OUT_OF_BOUNDS))
    {
        uint32_t    fromTop = address % CY_FLASH_SIZEOF_ROW;
        if (fromTop != 0)
        {
            memcpy(workBuff, (const void*)(address - fromTop), fromTop);
            memcpy(&workBuff[fromTop], data, (CY_FLASH_SIZEOF_ROW - fromTop));
            rc = Cy_Flash_ProgramRow((address - fromTop), (const uint32_t*)workBuff);
            address += (CY_FLASH_SIZEOF_ROW - fromTop);
            len -= (CY_FLASH_SIZEOF_ROW - fromTop);
            data += (CY_FLASH_SIZEOF_ROW - fromTop);
        }
        while ((len > 0) && (rc == CY_FLASH_DRV_SUCCESS))
        {
            uint8_t *ptr;
            if (len > CY_FLASH_SIZEOF_ROW)
            {
                size = CY_FLASH_SIZEOF_ROW;
                ptr = data;
            }
            else
            {
                size = len;
                memcpy(workBuff, data, size);
                memcpy(&workBuff[size], (uint8_t*)(address + size), (CY_FLASH_SIZEOF_ROW - size));
                ptr = workBuff;
            }
            rc = Cy_Flash_ProgramRow(address, (const uint32_t*)ptr);
            address += size;
            len -= size;
            data += size;
        }
    }
    else
    {
        rc = CY_FLASH_DRV_INVALID_INPUT_PARAMETERS;
    }

    /* Return error code */
    switch(rc)
    {
    case CY_FLASH_DRV_SUCCESS:
        retCode = IF_WR_SUCCESS;
        break;

    case CY_FLASH_DRV_INVALID_INPUT_PARAMETERS:
    case CY_FLASH_DRV_INVALID_FLASH_ADDR:
        retCode = IF_WR_ERROR_INVALID_PARAMETER;
        break;

    default:
        retCode = IF_WR_ERROR_FLASH_WRITE;
        break;
    }

    Cy_Flashc_MainWriteDisable();

    return retCode;
}

/**********************************************************************************************************************
 * Function Name: InternalFlashRead
 * Summary:
 *  Read from the internal flash
 * Parameters:
 *  off_t addr: source address to be read
 *  void *data: destination address
 *  size_t len: length
 * Return:
 *  int
 *   always returns 0
 **********************************************************************************************************************
 */
int InternalFlashRead(off_t addr, void *data, size_t len)
{
    /* flash read by simple memory copy */
    memcpy((void *)data, (const void*)addr, (size_t)len);

    return 0;
}

/**********************************************************************************************************************
 * Function Name: InternalFlashWrite
 * Summary:
 *  Write to the internal flash
 * Parameters:
 *  off_t addr: destination address to be written
 *  void *data: source data address
 *  size_t len: length
 * Return:
 *  int
 *   IF_WR_SUCCESS                  A successful write
 *   IF_WR_ERROR_INVALID_PARAMETER  At least one of the input parameters is invalid
 *   IF_WR_ERROR_FLASH_WRITE        Error in flash Write
 **********************************************************************************************************************
 */
int InternalFlashWrite(off_t addr, const void *data, size_t len)
{
    int rc;

    rc = IfWrite((uint8_t *)data, addr, len);

    return rc;
}

/**********************************************************************************************************************
 * Function Name: InternalFlashErase
 * Summary:
 *  Erase the internal flash
 * Parameters:
 *  off_t addr: start address to be erased
 *  size_t size: the size to be erased
 * Return:
 *  int
 *   0: success
 *   other than 0: failure
 **********************************************************************************************************************
 */
int InternalFlashErase(off_t addr, size_t size)
{
    int rc = 0;

    uint32_t        endAddr;
    if_bounds_t     boundsStart, boundsEnd;
    uint32_t        startSectorTopAddr, endSectorTopAddr;

    endAddr = addr + size;

    assert((addr % CY_FLASH_SIZEOF_ROW) == 0);
    assert((endAddr % CY_FLASH_SIZEOF_ROW) == 0);

    startSectorTopAddr = addr;
    IfGetSectorTopAddr(&startSectorTopAddr, false);
    endSectorTopAddr = endAddr;
    IfGetSectorTopAddr(&endSectorTopAddr, false);

    Cy_Flashc_MainWriteEnable();

    /* all erase target is included in a sector */
    if (startSectorTopAddr == endSectorTopAddr)
    {
        /* get top address of next sector */
        IfGetSectorTopAddr(&endSectorTopAddr, true);

        /* read the sector */
        memcpy(workBuff, (uint8_t *)startSectorTopAddr, (endSectorTopAddr - startSectorTopAddr));

        /* erase the sector */
        rc = Cy_Flash_EraseSector(startSectorTopAddr);
        assert(rc == CY_FLASH_DRV_SUCCESS);

        /* write stored back (from top to erase target) */
        if (addr != startSectorTopAddr)
        {
            rc = IfWrite(workBuff, startSectorTopAddr, (addr - startSectorTopAddr));
            assert(rc == IF_WR_SUCCESS);
        }
        /* write stored back (from erase target's end to end of the sector) */
        if (endAddr != endSectorTopAddr)
        {
            rc = IfWrite(&workBuff[endAddr - startSectorTopAddr], endAddr, (endSectorTopAddr - endAddr));
            assert(rc == IF_WR_SUCCESS);
        }
    }
    else
    {
        /* find if area bounds are aligned to sectors */
        boundsStart = IfMainBoundsCheck(addr);
        assert(boundsStart != IF_OUT_OF_BOUNDS);
        boundsEnd = IfMainBoundsCheck(endAddr);
        assert(boundsEnd != IF_OUT_OF_BOUNDS);

        /* first sector is fragmented */
        if (boundsStart != IF_ON_BOUNDS)
        {
            /* read value that should be remained */
            memcpy(workBuff, (const void*)startSectorTopAddr, (addr - startSectorTopAddr));

            /* erase fragmented sector */
            rc = Cy_Flash_EraseSector(startSectorTopAddr);
            assert(rc == CY_FLASH_DRV_SUCCESS);

            /* write stored back */
            rc = IfWrite(workBuff, startSectorTopAddr, (addr - startSectorTopAddr));
            assert(rc == IF_WR_SUCCESS);

            /* adjust address and size to be erased */
            IfGetSectorTopAddr(&startSectorTopAddr, true);
            size -= (startSectorTopAddr - addr);
            addr = startSectorTopAddr;
        }

        while (size != 0)
        {
            /* get top address of next sector */
            startSectorTopAddr = addr;
            IfGetSectorTopAddr(&startSectorTopAddr, true);

            /* reached to last non-fragmented sector */
            if (startSectorTopAddr > endAddr)
            {
                break;
            }

            /* erase whole of the sector */
            rc = Cy_Flash_EraseSector(addr);
            assert(rc == CY_FLASH_DRV_SUCCESS);

            /* adjust address and size to be erased */
            size -= (startSectorTopAddr - addr);
            addr = startSectorTopAddr;
        }

        assert((boundsEnd == IF_ON_BOUNDS && size == 0) || (boundsEnd == IF_IN_BOUNDS && size != 0));

        /* last sector is fragmented */
        if (boundsEnd != IF_ON_BOUNDS)
        {
            endSectorTopAddr = addr;

            /* read value that should be remained */
            IfGetSectorTopAddr(&endSectorTopAddr, true);
            memcpy(workBuff, (const void*)(addr + size), (endSectorTopAddr - addr - size));

            /* erase fragmented sector */
            rc = Cy_Flash_EraseSector(addr);
            assert(rc == CY_FLASH_DRV_SUCCESS);

            /* write stored back */
            rc = IfWrite(workBuff, addr + size, (endSectorTopAddr - addr - size));
            assert(rc == IF_WR_SUCCESS);
        }
    }

    Cy_Flashc_MainWriteDisable();

    return rc;
}

/* [] END OF FILE */
